
module Register(
    input  [15:0] D_in,
    input         wEnable,
    input         reset,
    input         clk,
    output reg [15:0] r
);
    always @(posedge clk) begin
        if (reset)        r <= 16'h0000;
        else if (wEnable) r <= D_in;
    end
endmodule



module RegBank(
    input         clk,
    input         reset,
    input  [15:0] wData,         // data written on posedge when enabled
    input  [15:0] regEnable,     // one-hot write enables for R0..R15
    input  [3:0]  ra_idx,        // read address A
    input  [3:0]  rb_idx,        // read address B
    output [15:0] busA,
    output [15:0] busB_reg
);
    // 16 registers
    wire [15:0] reg_data [0:15];

    genvar i;
    generate
        for (i=0; i<16; i=i+1) begin : GEN_REG
            Register u_reg (
                .D_in    (wData),
                .wEnable (regEnable[i]),
                .reset   (reset),
                .clk     (clk),
                .r       (reg_data[i])
            );
        end
    endgenerate

    reg [15:0] A_r, B_r;
    integer j, k;

    always @* begin
        A_r = 16'h0000;
        for (k=0; k<16; k=k+1)
            if (ra_idx == k[3:0]) A_r = reg_data[k];

        B_r = 16'h0000;
        for (j=0; j<16; j=j+1)
            if (rb_idx == j[3:0]) B_r = reg_data[j];
    end

    assign busA     = A_r;
    assign busB_reg = B_r;
endmodule



module mux(
    input  [15:0] d0,
    input  [15:0] d1,
    input         sel,
    output [15:0] y
);
    assign y = sel ? d1 : d0;
endmodule



module RegALU(
    input         clk,
    input         reset,
    input         wEnable,        // global write enable for rd_idx
    input  [3:0]  ra_idx,         // read A index
    input  [3:0]  rb_idx,         // read B index
    input  [3:0]  rd_idx,         // write dest index
    input  [7:0]  opcode,         // ALU opcode (to Lab1)
    input         cin,            // ALU carry-in
    input  [15:0] immB,           // immediate value for B
    input         selB_imm,       // 1: ALU.B <- immB, 0: ALU.B <- reg
    output [15:0] alu_out,        // ALU result (also write-back data)
    output [4:0]  flags           // ALU flags
);
    // one-hot write enables
    wire [15:0] regEnable = wEnable ? (16'h0001 << rd_idx) : 16'h0000;

    // register bank
    wire [15:0] busA, busB_reg;
    RegBank uRegBank (
        .clk       (clk),
        .reset     (reset),
        .wData     (alu_out),     // write-back from ALU
        .regEnable (regEnable),
        .ra_idx    (ra_idx),
        .rb_idx    (rb_idx),
        .busA      (busA),
        .busB_reg  (busB_reg)
    );

    // select B = reg or immediate
    wire [15:0] alu_A = busA;
    wire [15:0] alu_B;
    mux MUXB_IMM(busB_reg, immB, selB_imm, alu_B);


    Lab1 ALU (
        .A      (alu_A),
        .B      (alu_B),
        .Cin    (cin),
        .Opcode (opcode),
        .C      (alu_out),
        .Flags  (flags)
    );
endmodule



module fib_fsm (
   input  wire clk, rst,
   input  wire step,                 

   output reg [3:0] rs1, rs2, rd,      // regfile source1, source2, destination
   output reg       reg_en, done,      // regfile write enable + finish flag 
   output reg [7:0] alu_op,            // ALU opcode
   output reg [15:0] data_in,          // immediate for init
   output reg       use_imm
);
   // FSM states
   parameter init0  = 5'd0, 
             init1  = 5'd1, 
             add2   = 5'd2, 
             add3   = 5'd3,
             add4   = 5'd4,
             add5   = 5'd5,
             add6   = 5'd6,
             add7   = 5'd7,
             add8   = 5'd8,
             add9   = 5'd9,
             add10  = 5'd10,
             add11  = 5'd11,
             add12  = 5'd12,
             add13  = 5'd13,
             add14  = 5'd14,
             add15  = 5'd15,
             finish = 5'd16;

   reg [4:0] state, next_state;

   // next-state
   always @(*) begin
      case (state)
        init0:  next_state = init1;
        init1:  next_state = add2;
        add2:   next_state = add3;
        add3:   next_state = add4;
        add4:   next_state = add5;
        add5:   next_state = add6;
        add6:   next_state = add7;
        add7:   next_state = add8;
        add8:   next_state = add9;
        add9:   next_state = add10;
        add10:  next_state = add11;
        add11:  next_state = add12;
        add12:  next_state = add13;
        add13:  next_state = add14;
        add14:  next_state = add15;
        add15:  next_state = finish;
        finish: next_state = finish;
        default:next_state = init0;
      endcase
   end

   always @(posedge clk) begin
      if (rst) state <= init0;
      else if (step) state <= next_state;
   end

   // outputs
   always @(*) begin
      // defaults
      rs1=0; rs2=0; rd=0; reg_en=0; alu_op=8'h00; data_in=16'd0; use_imm=0; done=0;

      case (state)
        // initialize Fibonacci base cases: R0=1, R1=1
        init0: begin rs1=15; rs2=15; rd=0; data_in=16'd1; reg_en=1; use_imm=1; alu_op=8'h00; end
        init1: begin rs1=15; rs2=15; rd=1; data_in=16'd1; reg_en=1; use_imm=1; alu_op=8'h00; end

        // Fibonacci additions
        add2:  begin rs1=0;  rs2=1;  rd=2;  reg_en=1; use_imm=0; alu_op=8'h00; end
        add3:  begin rs1=1;  rs2=2;  rd=3;  reg_en=1; use_imm=0; alu_op=8'h00; end
        add4:  begin rs1=2;  rs2=3;  rd=4;  reg_en=1; use_imm=0; alu_op=8'h00; end
        add5:  begin rs1=3;  rs2=4;  rd=5;  reg_en=1; use_imm=0; alu_op=8'h00; end
        add6:  begin rs1=4;  rs2=5;  rd=6;  reg_en=1; use_imm=0; alu_op=8'h00; end
        add7:  begin rs1=5;  rs2=6;  rd=7;  reg_en=1; use_imm=0; alu_op=8'h00; end
        add8:  begin rs1=6;  rs2=7;  rd=8;  reg_en=1; use_imm=0; alu_op=8'h00; end
        add9:  begin rs1=7;  rs2=8;  rd=9;  reg_en=1; use_imm=0; alu_op=8'h00; end
        add10: begin rs1=8;  rs2=9;  rd=10; reg_en=1; use_imm=0; alu_op=8'h00; end
        add11: begin rs1=9;  rs2=10; rd=11; reg_en=1; use_imm=0; alu_op=8'h00; end
        add12: begin rs1=10; rs2=11; rd=12; reg_en=1; use_imm=0; alu_op=8'h00; end
        add13: begin rs1=11; rs2=12; rd=13; reg_en=1; use_imm=0; alu_op=8'h00; end
        add14: begin rs1=12; rs2=13; rd=14; reg_en=1; use_imm=0; alu_op=8'h00; end
        add15: begin rs1=13; rs2=14; rd=15; reg_en=1; use_imm=0; alu_op=8'h00; end

        finish: begin done=1; end
      endcase
   end
endmodule


module btn_onepulse #(
  parameter CNT_MAX = 500_000      // ~10ms @50MHz
)(
  input  clk, rst,
  input  btn_in,                   // async, active-high
  output reg pulse                 // 1-cycle pulse
);
  // sync 2FF
  reg d0, d1;
  always @(posedge clk) begin d0 <= btn_in; d1 <= d0; end

  // debounce
  reg [$clog2(CNT_MAX):0] cnt; 
  reg stable;
  always @(posedge clk or posedge rst) begin
    if (rst) begin
      cnt<=0; stable<=0;
    end else if (d1!=stable) begin
      cnt <= cnt + 1;
      if (cnt==CNT_MAX) begin
        stable<=d1; 
        cnt<=0; 
      end
    end else begin
      cnt<=0;
    end
  end

  // one-pulse on rising edge
  reg stable_q;
  always @(posedge clk or posedge rst) begin
    if (rst) begin
      stable_q<=0; 
      pulse<=0;
    end else begin
      pulse <= (stable & ~stable_q);
      stable_q <= stable;
    end
  end
endmodule


module Lab2 (
  input         CLOCK_50,
  input  [1:0]  KEY,                // KEY[1]=RESET_N, KEY[0]=STEP_N
  output [6:0]  HEX0, HEX1, HEX2, HEX3
);

  wire reset    = ~KEY[1];
  wire step_btn = ~KEY[0];          // active-high ë²„íŠ¼

  wire step_pulse;
  btn_onepulse #(.CNT_MAX(500_000)) u_step (
    .clk   (CLOCK_50),
    .rst   (reset),
    .btn_in(step_btn),
    .pulse (step_pulse)
  );

  // FSM + RegALU
  wire [15:0] alu_out;
  wire [4:0]  flags;


  wire [3:0] ra_idx, rb_idx, rd_idx;
  wire       wEnable, selB_imm;
  wire [7:0] alu_op;
  wire [15:0] immB;
  wire       done_unused;

  // fib_fsm: rs1/rs2/rd/reg_en/alu_op/data_in/use_imm
  fib_fsm U_FSM (
    .clk     (CLOCK_50),
    .rst     (reset),
    .step    (step_pulse),
    .rs1     (ra_idx),
    .rs2     (rb_idx),
    .rd      (rd_idx),
    .reg_en  (wEnable),
    .alu_op  (alu_op),
    .data_in (immB),
    .use_imm (selB_imm),
    .done    (done_unused)
  );

  // Datapath: RegBank + Lab1(ALU)
  RegALU U_DATAPATH (
    .clk       (CLOCK_50),
    .reset     (reset),
    .wEnable   (wEnable),
    .ra_idx    (ra_idx),
    .rb_idx    (rb_idx),
    .rd_idx    (rd_idx),
    .opcode    (alu_op),
    .cin       (1'b0),         
    .immB      (immB),
    .selB_imm  (selB_imm),
    .alu_out   (alu_out),
    .flags     (flags)
  );


  function [6:0] hex7seg_ah; input [3:0] n; begin
    case (n)
      4'h0: hex7seg_ah = 7'b0111111; 4'h1: hex7seg_ah = 7'b0000110;
      4'h2: hex7seg_ah = 7'b1011011; 4'h3: hex7seg_ah = 7'b1001111;
      4'h4: hex7seg_ah = 7'b1100110; 4'h5: hex7seg_ah = 7'b1101101;
      4'h6: hex7seg_ah = 7'b1111101; 4'h7: hex7seg_ah = 7'b0000111;
      4'h8: hex7seg_ah = 7'b1111111; 4'h9: hex7seg_ah = 7'b1100111;
      4'hA: hex7seg_ah = 7'b1110111; 4'hB: hex7seg_ah = 7'b1111100;
      4'hC: hex7seg_ah = 7'b0111001; 4'hD: hex7seg_ah = 7'b1011110;
      4'hE: hex7seg_ah = 7'b1111001; 4'hF: hex7seg_ah = 7'b1110001;
      default: hex7seg_ah = 7'b0000000;
    endcase
  end endfunction

  wire [3:0] n3 = alu_out[15:12];
  wire [3:0] n2 = alu_out[11:8];
  wire [3:0] n1 = alu_out[7:4];
  wire [3:0] n0 = alu_out[3:0];


  assign HEX3 = ~hex7seg_ah(n3);
  assign HEX2 = ~hex7seg_ah(n2);
  assign HEX1 = ~hex7seg_ah(n1);
  assign HEX0 = ~hex7seg_ah(n0);

endmodule
