module Register(
    input  [15:0] D_in,
    input         wEnable,
    input         reset,
    input         clk,
    output reg [15:0] r
);
    always @(posedge clk) begin
        if (reset)        r <= 16'h0000;
        else if (wEnable) r <= D_in;
    end
endmodule


module RegBank(
    input         clk,
    input         reset,
    input  [15:0] wData,         // data written on posedge when enabled
    input  [15:0] regEnable,     // one-hot write enables for R0..R15
    input  [3:0]  ra_idx,        // read address A
    input  [3:0]  rb_idx,        // read address B
    output [15:0] busA,
    output [15:0] busB_reg
);
    // 16 registers
    wire [15:0] reg_data [0:15];

    genvar i;
    generate
        for (i=0; i<16; i=i+1) begin : GEN_REG
            Register u_reg (
                .D_in    (wData),
                .wEnable (regEnable[i]),
                .reset   (reset),
                .clk     (clk),
                .r       (reg_data[i])
            );
        end
    endgenerate


    reg [15:0] A_r, B_r;
    integer j, k;

    always @* begin
        A_r = 16'h0000;
        for (k=0; k<16; k=k+1)
            if (ra_idx == k[3:0]) A_r = reg_data[k];

        B_r = 16'h0000;
        for (j=0; j<16; j=j+1)
            if (rb_idx == j[3:0]) B_r = reg_data[j];
    end

    assign busA     = A_r;
    assign busB_reg = B_r;
endmodule



module mux(
    input  [15:0] d0,
    input  [15:0] d1,
    input         sel,
    output [15:0] y
);
    assign y = sel ? d1 : d0;
endmodule



module RegALU(
    input         clk,
    input         reset,
    input         wEnable,        // global write enable for rd_idx
    input  [3:0]  ra_idx,         // read A index
    input  [3:0]  rb_idx,         // read B index
    input  [3:0]  rd_idx,         // write dest index
    input  [7:0]  opcode,         // ALU opcode (to Lab1)
    input         cin,            // ALU carry-in
    input  [15:0] immB,           // immediate value for B
    input         selB_imm,       // 1: ALU.B <- immB, 0: ALU.B <- reg
    output [15:0] alu_out,        // ALU result (also write-back data)
    output [4:0]  flags           // ALU flags
);
    // one-hot write enables
    wire [15:0] regEnable = wEnable ? (16'h0001 << rd_idx) : 16'h0000;

    // register bank
    wire [15:0] busA, busB_reg;
    RegBank uRegBank (
        .clk       (clk),
        .reset     (reset),
        .wData     (alu_out),     // write-back from ALU
        .regEnable (regEnable),
        .ra_idx    (ra_idx),
        .rb_idx    (rb_idx),
        .busA      (busA),
        .busB_reg  (busB_reg)
    );

    // select B = reg or immediate
    wire [15:0] alu_A = busA;
    wire [15:0] alu_B;
    mux MUXB_IMM(busB_reg, immB, selB_imm, alu_B);


    Lab1 ALU (
        .A      (alu_A),
        .B      (alu_B),
        .Cin    (cin),
        .Opcode (opcode),
        .C      (alu_out),
        .Flags  (flags)

    );
endmodule



module Lab2(
    input        clk,
    input        rst,
    input        cin,          // tie to 1'b0 if unused
    output [15:0] alu_out,
    output [4:0]  flags
);
    // FSM wires
    wire [3:0] ra_idx, rb_idx, rd_idx;
    wire       wEnable, selB_imm;
    wire [7:0] alu_op;
    wire [15:0] immB;

    //change name
	 fib_fsm U_FSM (
	 //fsm_signed U_FSM (
	 //fsm_logicmix U_FSM (
        .clk      (clk),
        .rst      (rst),
        .ra_idx   (ra_idx),
        .rb_idx   (rb_idx),
        .rd_idx   (rd_idx),
        .wEnable  (wEnable),
        .alu_op   (alu_op),
        .selB_imm (selB_imm),
        .immB     (immB)
    );

    RegALU U_DATAPATH (
        .clk       (clk),
        .reset     (rst),
        .wEnable   (wEnable),
        .ra_idx    (ra_idx),
        .rb_idx    (rb_idx),
        .rd_idx    (rd_idx),
        .opcode    (alu_op),
        .cin       (cin),
        .immB      (immB),
        .selB_imm  (selB_imm),
        .alu_out   (alu_out),
        .flags     (flags)
    );
endmodule
