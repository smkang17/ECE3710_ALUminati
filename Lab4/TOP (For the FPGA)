module CPU_Control (
    input  wire clk,
    input  wire rst,
	 	 output wire [6:0]  HEX0,
    output wire [6:0]  HEX1,
    output wire [6:0]  HEX2,
    output wire [6:0]  HEX3
);

    wire [15:0] PC_value;
    wire [15:0] mem_dout;   // use this in IR module as an input
    wire        PCe;        // PC enable
    wire        Ren;        // Register write enable
    wire [3:0]  Rsrc;       // Source reg index
    wire [3:0]  Rdest;      // Destination reg index
    wire        R_I;        // Reg/Imm select
    wire [7:0]  Opcode;     // ALU opcode
    wire [7:0]  Imm;        // Immediate value
	 wire 		 mem_WE;		 // Memory write enable (for STORE)
    wire [15:0] alu_out;
    wire [4:0]  flags;
	 wire [15:0] busA_out;   
	 wire [15:0] busB_out;
	 wire	    	 LSCntl; 
	 wire 		 ALU_MUX_Cntl; 


		 
	 	   // Reset button polarity
  localparam RST_ACTIVE_LOW = 1;
  wire rst_int = (RST_ACTIVE_LOW) ? ~rst : rst;
  
    // === clock divider ===
    reg [25:0] slow_count;
    always @(posedge clk or posedge rst_int) begin
        if (rst_int)
            slow_count <= 26'd0;
        else
            slow_count <= slow_count + 1;
    end
    wire slow_clk = slow_count[25];




	 
	 // LSCntl MUX
    reg [15:0] mem_addr;
    always @(LSCntl or PC_value or busB_out) begin
        case (LSCntl)
            1'b0: mem_addr = PC_value;               // instruction fetch
            1'b1: mem_addr = busB_out;               // simulated reg value
            default: mem_addr = 16'h0000;
        endcase
    end
	 
	 
	 //ALU_MUX_Cntl MUX
	 reg [15:0] wb_data;
	 always @(ALU_MUX_Cntl or alu_out or mem_dout) begin
        case (ALU_MUX_Cntl)
            1'b0: wb_data = alu_out;               // instruction fetch
            1'b1: wb_data = mem_dout;               // simulated reg value
            default: wb_data = 16'h0000;
        endcase
    end
	 
	 
	 
    pc uPC (
        .clk(slow_clk),
        .rst(rst_int),
        .PCe(PCe),
        .pc_value(PC_value)
    );

    controlFSM uFSM (
        .clk(slow_clk),
        .rst(rst_int),
        .inst(mem_dout),
        .PCe(PCe),
        .Ren(Ren),
        .Rsrc(Rsrc),
        .Rdest(Rdest),
        .R_I(R_I),
        .Opcode(Opcode),
        .Imm(Imm),
		  .mem_WE(mem_WE),
		  .LSCntl(LSCntl),
		  .ALU_MUX_Cntl(ALU_MUX_Cntl)
    );

    RegALU uRegALU (
        .clk(slow_clk),
        .reset(rst_int),
        .wEnable(Ren),         // from FSM
        .ra_idx(Rdest),
        .rb_idx(Rsrc),         // for now, same as source â€” can adjust if you have Rb field
        .opcode(Opcode),
        //.cin(1'b0),         
        .immB({8'h00, Imm}),   // zero-extend immediate
        .selB_imm(R_I),
        .alu_out(alu_out),
        .flags(flags),
		  .busA_out(busA_out),
		  .busB_out(busB_out),
		  .wb_data(wb_data)
    );

	 
	 //b not used yet
	 Bram uBram (
        .data_a(busA_out),   	// data stored from Rsrc during store inst
        .data_b(16'h0000),		
        .addr_a(mem_addr),    // instruction address = PC
        .addr_b(1'b0),
        .we_a(mem_WE),
        .we_b(1'b0),			// FSM controls WE
        .clk(slow_clk),
        .q_a(mem_dout),
        .q_b()
    );
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 
	 	 // === HEX display function ===
	 function [6:0] hex7seg_ah;
		input [3:0] n;
		begin
			case (n)
				4'h0: hex7seg_ah = 7'b0111111; 4'h1: hex7seg_ah = 7'b0000110;
				4'h2: hex7seg_ah = 7'b1011011; 4'h3: hex7seg_ah = 7'b1001111;
				4'h4: hex7seg_ah = 7'b1100110; 4'h5: hex7seg_ah = 7'b1101101;
				4'h6: hex7seg_ah = 7'b1111101; 4'h7: hex7seg_ah = 7'b0000111;
				4'h8: hex7seg_ah = 7'b1111111; 4'h9: hex7seg_ah = 7'b1100111;
				4'hA: hex7seg_ah = 7'b1110111; 4'hB: hex7seg_ah = 7'b1111100;
				4'hC: hex7seg_ah = 7'b0111001; 4'hD: hex7seg_ah = 7'b1011110;
				4'hE: hex7seg_ah = 7'b1111001; 4'hF: hex7seg_ah = 7'b1110001;
				default: hex7seg_ah = 7'b0000000;
			endcase
		end
	 endfunction
	 
	 
	 wire [15:0] display_value = alu_out; //display_value = {8'h00, PC_value[7:0]};
	 
	 // Split 16-bit value across 4 displays
	 assign HEX3 = ~hex7seg_ah(display_value[15:12]);
	 assign HEX2 = ~hex7seg_ah(display_value[11:8]);
	 assign HEX1 = ~hex7seg_ah(display_value[7:4]);
    assign HEX0 = ~hex7seg_ah(display_value[3:0]);

endmodule
