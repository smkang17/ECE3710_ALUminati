//There are 3 scenarios which are fib, signed_fib, and logic mix
//signed_fib is just subtracting 1
//logic mix is checking for other opcodes, all the conditions are written





////fib_fsm
module fib_fsm (
    input  wire       clk, rst,
    output reg  [3:0] ra_idx, rb_idx, rd_idx,
    output reg        wEnable,
    output reg  [7:0] alu_op,
    output reg        selB_imm,
    output reg [15:0] immB
);
    localparam S_INIT0 = 5'd0,
               S_INIT1 = 5'd1,
               S_K2    = 5'd2,
               S_K3    = 5'd3,
               S_K4    = 5'd4,
               S_K5    = 5'd5,
               S_K6    = 5'd6,
               S_K7    = 5'd7,
               S_K8    = 5'd8,
               S_K9    = 5'd9,
               S_K10   = 5'd10,
               S_K11   = 5'd11,
               S_K12   = 5'd12,
               S_K13   = 5'd13,
               S_K14   = 5'd14,
               S_K15   = 5'd15,
               S_DONE  = 5'd31;

    reg [4:0] state, next_state;


    always @(posedge clk) begin
        if (rst) begin
            state      <= S_INIT0;
            next_state <= S_INIT0;
        end else begin
            state      <= next_state;  
            case (state)               
                S_INIT0: next_state <= S_INIT1;
                S_INIT1: next_state <= S_K2;
                S_K2:    next_state <= S_K3;
                S_K3:    next_state <= S_K4;
                S_K4:    next_state <= S_K5;
                S_K5:    next_state <= S_K6;
                S_K6:    next_state <= S_K7;
                S_K7:    next_state <= S_K8;
                S_K8:    next_state <= S_K9;
                S_K9:    next_state <= S_K10;
                S_K10:   next_state <= S_K11;
                S_K11:   next_state <= S_K12;
                S_K12:   next_state <= S_K13;
                S_K13:   next_state <= S_K14;
                S_K14:   next_state <= S_K15;
                S_K15:   next_state <= S_DONE;
                default: next_state <= S_DONE;
            endcase
        end
    end


    always @(state) begin
        ra_idx=0; rb_idx=0; rd_idx=0;
        wEnable=0; alu_op=8'h00; selB_imm=0; immB=16'h0000;

        case (state)
            S_INIT0: begin rd_idx=0; wEnable=1; selB_imm=1; alu_op=8'h00; immB=16'h0000; end
            S_INIT1: begin rd_idx=1; wEnable=1; selB_imm=1; alu_op=8'h00; immB=16'h0001; end

            S_K2:  begin ra_idx=0; rb_idx=1; rd_idx=2;  wEnable=1; alu_op=8'h00; end
            S_K3:  begin ra_idx=1; rb_idx=2; rd_idx=3;  wEnable=1; alu_op=8'h00; end
            S_K4:  begin ra_idx=2; rb_idx=3; rd_idx=4;  wEnable=1; alu_op=8'h00; end
            S_K5:  begin ra_idx=3; rb_idx=4; rd_idx=5;  wEnable=1; alu_op=8'h00; end
            S_K6:  begin ra_idx=4; rb_idx=5; rd_idx=6;  wEnable=1; alu_op=8'h00; end
            S_K7:  begin ra_idx=5; rb_idx=6; rd_idx=7;  wEnable=1; alu_op=8'h00; end
            S_K8:  begin ra_idx=6; rb_idx=7; rd_idx=8;  wEnable=1; alu_op=8'h00; end
            S_K9:  begin ra_idx=7; rb_idx=8; rd_idx=9;  wEnable=1; alu_op=8'h00; end
            S_K10: begin ra_idx=8; rb_idx=9; rd_idx=10; wEnable=1; alu_op=8'h00; end
            S_K11: begin ra_idx=9; rb_idx=10;rd_idx=11; wEnable=1; alu_op=8'h00; end
            S_K12: begin ra_idx=10;rb_idx=11;rd_idx=12; wEnable=1; alu_op=8'h00; end
            S_K13: begin ra_idx=11;rb_idx=12;rd_idx=13; wEnable=1; alu_op=8'h00; end
            S_K14: begin ra_idx=12;rb_idx=13;rd_idx=14; wEnable=1; alu_op=8'h00; end
            S_K15: begin ra_idx=13;rb_idx=14;rd_idx=15; wEnable=1; alu_op=8'h00; end
        endcase
    end
endmodule


















////fsm_signed
module fsm_signed (
    input  wire       clk, rst,
    output reg  [3:0] ra_idx, rb_idx, rd_idx,
    output reg        wEnable,
    output reg  [7:0] alu_op,
    output reg        selB_imm,
    output reg [15:0] immB
);
    localparam S_LOAD0=0, S_LOAD1=1, S_ADD=2, S_SUB=3, S_LOOP=4, S_DONE=31;
    reg [4:0] st,nst; reg [3:0] i,ni;

    always @(posedge clk) begin
        if (rst) begin st<=S_LOAD0; i<=4'd2; end
        else begin st<=nst; i<=ni; end
    end

    always @* begin
        nst=st; ni=i;
        case (st)
            S_LOAD0: nst=S_LOAD1;                // R0 <- -1
            S_LOAD1: nst=S_ADD;                  // R1 <- +2
            S_ADD  : nst=S_SUB;                  // R2 <- R0 + R1 (=1)
            S_SUB  : nst=S_LOOP;                 // R3 <- R2 - R1 (=-1)
            S_LOOP : begin
                if (i==4'd15) nst=S_DONE;
                else begin nst=S_LOOP; ni=i+1; end
            end
            default: nst=S_DONE;
        endcase
    end

    always @* begin
        ra_idx=0; rb_idx=0; rd_idx=0; wEnable=0; alu_op=8'h00; selB_imm=0; immB=0;
        case (st)
            S_LOAD0: begin // R0 <- -1 (0xFFFF)
                ra_idx=0; rb_idx=0; rd_idx=0; wEnable=1; selB_imm=1; alu_op=8'h00; immB=16'hFFFF;
            end
            S_LOAD1: begin // R1 <- +2
                ra_idx=1; rb_idx=1; rd_idx=1; wEnable=1; selB_imm=1; alu_op=8'h00; immB=16'h0002;
            end
            S_ADD: begin   // R2 <- R0 + R1  (=1)
                ra_idx=0; rb_idx=1; rd_idx=2; wEnable=1; selB_imm=0; alu_op=8'h00;
            end
            S_SUB: begin   // R3 <- R2 - R1  (=-1)
                ra_idx=2; rb_idx=1; rd_idx=3; wEnable=1; selB_imm=0; alu_op=8'h08;
            end
            S_LOOP: begin  // R(i) <- R(i-1) + R0  
                ra_idx=i-1; rb_idx=0; rd_idx=i; wEnable=1; selB_imm=0; alu_op=8'h00;
            end
            default: wEnable=0;
        endcase
    end
endmodule













////fsm_logicmix
module fsm_logicmix (
    input  wire       clk, rst,
    output reg  [3:0] ra_idx, rb_idx, rd_idx,
    output reg        wEnable,
    output reg  [7:0] alu_op,
    output reg        selB_imm,
    output reg [15:0] immB
);
    localparam
      L_R0=0, L_R1=1, AND2=2, OR3=3, XOR4=4, NOT5=5,
      ADD6=6, SUB7=7, LSH8=8, RSH9=9, DONE=10;
    reg [4:0] st,nst;

    always @(posedge clk) if (rst) st<=L_R0; else st<=nst;

    always @* begin
        nst=st;
        case (st)
            L_R0: nst=L_R1;
            L_R1: nst=AND2;
            AND2: nst=OR3;
            OR3:  nst=XOR4;
            XOR4: nst=NOT5;
            NOT5: nst=ADD6;
            ADD6:  nst=SUB7;
            SUB7:  nst=LSH8;
            LSH8:  nst=RSH9;
            RSH9:  nst=DONE;
            default: nst=DONE;
        endcase
    end

    always @* begin
        ra_idx=0; rb_idx=0; rd_idx=0; wEnable=0; alu_op=8'h00; selB_imm=0; immB=16'h0;
        case (st)
				L_R0: begin
            ra_idx=0; rd_idx=0; wEnable=1; selB_imm=1; alu_op=8'h00; immB=16'h00FF;
				end
						
				L_R1: begin
					ra_idx=1; rd_idx=1; wEnable=1; selB_imm=1; alu_op=8'h00; immB=16'h0F0F;
				end
            AND2: begin 
                ra_idx=0; rb_idx=1; rd_idx=2; wEnable=1; alu_op=8'h0D; selB_imm=0;
            end
            OR3: begin  
                ra_idx=0; rb_idx=1; rd_idx=3; wEnable=1; alu_op=8'h0E; selB_imm=0;
            end
            XOR4: begin 
                ra_idx=0; rb_idx=1; rd_idx=4; wEnable=1; alu_op=8'h0F; selB_imm=0;
            end
            NOT5: begin 
                ra_idx=0; rb_idx=0; rd_idx=5; wEnable=1; alu_op=8'h10; selB_imm=0;
            end
            ADD6: begin  
                ra_idx=3; rb_idx=2; rd_idx=6; wEnable=1; alu_op=8'h00; selB_imm=0;
            end
            SUB7: begin  
                ra_idx=6; rb_idx=4; rd_idx=7; wEnable=1; alu_op=8'h08; selB_imm=0;
            end
            LSH8: begin  
                ra_idx=7; rb_idx=7; rd_idx=8; wEnable=1;
                alu_op=8'h00; selB_imm=0; 
            end
            RSH9: begin  
                ra_idx=8; rb_idx=8; rd_idx=9; wEnable=1; 
                
                alu_op=8'h14; selB_imm=1; immB=16'd3; 
            end
            default: wEnable=0;
        endcase
    end
endmodule

