// PS2.v
// - PS/2 키보드에서 스캔코드(1바이트)를 받는다.
// - 마지막으로 받은 스캔코드를 LEDR/HEX로 보여준다.
// - key_decoder로 WASD/Space/R를 펄스로 만들고
// - game_controller로 방향/시작/정지/리셋 FSM을 돌린다.

module PS2 (
    input  wire CLOCK_50,
    input  wire KEY0,        // 보드 리셋 버튼 (active-low)
    input  wire PS2_CLK,
    input  wire PS2_DAT,

    // 보드에 직접 연결할 출력들
    output wire [9:0] LEDR,  // 하위 8bit: 마지막 스캔코드
    output wire [6:0] HEX0,  // 스캔코드의 낮은 nibble (16진수 한 자리)
    output wire [6:0] HEX1   // 스캔코드의 높은 nibble (16진수 한 자리)
);

    // ============================================================
    // Reset 신호 (active-high)
    // ============================================================
    wire rst = ~KEY0;

    // ============================================================
    // 1) PS/2 스캔코드 받기
    // ============================================================
    wire [7:0] scan_code;
    wire       scan_ready;

    // ps2_keyboard: PS/2 프로토콜을 읽어서 8비트 코드 + ready 펄스 생성
    ps2_keyboard u_ps2_kbd (
        .clk        (CLOCK_50),
        .rst        (rst),
        .ps2_clk    (PS2_CLK),
        .ps2_data   (PS2_DAT),
        .data_out   (scan_code),
        .data_ready (scan_ready)
    );

    // 최근에 들어온 스캔코드를 저장하는 레지스터
    reg [7:0] last_code;
    always @(posedge CLOCK_50 or posedge rst) begin
        if (rst)
            last_code <= 8'h00;
        else if (scan_ready)
            last_code <= scan_code;
    end

    // ============================================================
    // 2) LED / HEX 디스플레이 출력
    // ============================================================

    // LEDR[7:0] 에 raw 스캔코드 표시 (bit = 1이면 LED 켜짐)
    assign LEDR[7:0] = last_code;
    // 나머지 LEDR[9:8] 은 지금은 사용 안 함
    assign LEDR[9:8] = 2'b00;

    // 7-seg 에도 16진수 두 자리로 표시
    // 예: W 누르면 스캔코드 0x1D → HEX1 = 1, HEX0 = d
    hex7seg u_hex0 (
        .in  (last_code[3:0]),   // low nibble
        .out (HEX0)
    );

    hex7seg u_hex1 (
        .in  (last_code[7:4]),   // high nibble
        .out (HEX1)
    );

    // ============================================================
    // 3) key_decoder — WASD / Space / R 를 1클럭 펄스로
    // ============================================================
    wire w_press, a_press, s_press, d_press;
    wire space_press, r_press;

    key_decoder u_dec (
        .clk         (CLOCK_50),
        .rst         (rst),
        .data_in     (scan_code),
        .data_ready  (scan_ready),

        .w_press     (w_press),
        .a_press     (a_press),
        .s_press     (s_press),
        .d_press     (d_press),
        .space_press (space_press),
        .r_press     (r_press)
    );

    // ============================================================
    // 4) game_controller — 방향 + start/stop/reset FSM
    // ============================================================

    wire [2:0] dir;
    wire       game_run;
    wire       game_reset_pulse;

    // 아직 진짜 게임 코어가 없으니, game_over 는 0으로 고정
    wire game_over = 1'b0;

    game_controller u_gc (
        .clk              (CLOCK_50),
        .rst              (rst),

        .w_press          (w_press),
        .a_press          (a_press),
        .s_press          (s_press),
        .d_press          (d_press),
        .space_press      (space_press),
        .r_press          (r_press),

        .game_over        (game_over),

        .dir              (dir),
        .game_run         (game_run),
        .game_reset_pulse (game_reset_pulse)
    );

endmodule


// ==========================================================================
// hex7seg — DE1-SoC용 7-세그 헥사 디코더 (active-low)
// ==========================================================================

module hex7seg (
    input  wire [3:0] in,
    output reg  [6:0] out
);
    always @* begin
        //        gfedcba  (DE1-SoC 기본 예제와 동일한 패턴)
        case (in)
            4'h0: out = 7'b1000000;
            4'h1: out = 7'b1111001;
            4'h2: out = 7'b0100100;
            4'h3: out = 7'b0110000;
            4'h4: out = 7'b0011001;
            4'h5: out = 7'b0010010;
            4'h6: out = 7'b0000010;
            4'h7: out = 7'b1111000;
            4'h8: out = 7'b0000000;
            4'h9: out = 7'b0010000;
            4'hA: out = 7'b0001000; // A
            4'hB: out = 7'b0000011; // b
            4'hC: out = 7'b1000110; // C
            4'hD: out = 7'b0100001; // d
            4'hE: out = 7'b0000110; // E
            4'hF: out = 7'b0001110; // F
            default: out = 7'b1111111;
        endcase
    end
endmodule
