module Lab1(
    input  [7:0]  Opcode,
    input         Cin,
    output [15:0] C,
    output [4:0]  Flags,
    output [6:0]  seven_seg4, // C[15:12]
    output [6:0]  seven_seg3, // C[11:8]
    output [6:0]  seven_seg2, // C[7:4]
    output [6:0]  seven_seg1  // C[3:0]
);
    // Hard-coded operands
    wire [15:0] A_const = 16'd10;
    wire [15:0] B_const = 16'd2;

    ALU u_alu (
        .A(A_const),
        .B(B_const),
        .Opcode(Opcode),
        .Cin(Cin),
        .C(C),
        .Flags(Flags),
        .seven_seg4(seven_seg4),
        .seven_seg3(seven_seg3),
        .seven_seg2(seven_seg2),
        .seven_seg1(seven_seg1)
    );
endmodule




module ALU( A, B, C, Cin, Opcode, Flags, seven_seg4, seven_seg3, seven_seg2, seven_seg1);
input [15:0] A, B;    // 16 bits
input [7:0] Opcode;    // 8 bits
input Cin;
output reg [15:0] C;    // 16 bits
output reg [4:0] Flags;        // 5 flags
output reg [6:0]  seven_seg4;
output reg [6:0]  seven_seg3;
output reg [6:0]  seven_seg2;
output reg [6:0]  seven_seg1;

parameter ADD = 8'h00; 
parameter ADDI = 8'h01;
parameter ADDU = 8'h02;
parameter ADDUI = 8'h03;
parameter ADDC = 8'h04;
parameter ADDCU = 8'h05;
parameter ADDCUI = 8'h06;
parameter ADDCI = 8'h07;
parameter SUB = 8'h08;
parameter SUBI = 8'h09;
parameter CMP = 8'h0A;
parameter CMPI = 8'h0B;
parameter CMPU = 8'h0C;    // CMPU/I
parameter AND = 8'h0D;
parameter OR = 8'h0E;
parameter XOR = 8'h0F;
parameter NOT = 8'h10;
parameter LSH = 8'h11; 
parameter LSHI = 8'h12;
parameter RSH = 8'h13;
parameter RSHI = 8'h14;
parameter ALSH = 8'h15;
parameter ARSH = 8'h16;
parameter NOP = 8'h17;   

/* FLAGS (bit):
    [4]:    Negative
    [3]:    Z (zero)
    [2]:    Flag
    [1]:    Low
    [0]:    Carry
*/

always @(A,B, Opcode)
begin

   C = 16'h0000;
   Flags = 5'b00000;

   case (Opcode)
   
   ADD:            
      begin
         {Flags[0], C} = A + B;
         if (C == 16'h0000) Flags[3] = 1'h1;                                         //set zero bit if answer is 0
         else Flags[3] = 1'h0;
         if( (~A[15] & ~B[15] & C[15]) | (A[15] & B[15] & ~C[15]) ) Flags[2] = 1'h1; //set overflow
         else Flags [2] = 1'h0;
         Flags[4] = C[15];              
         Flags[1] = 1'h0;                 
      end
   
   ADDI:
      begin
         {Flags[0], C} = A + B;
         if (C == 16'h0000) Flags[3] = 1'h1;                                         //set zero bit if answer is 0
         else Flags[3] = 1'h0;
         if( (~A[15] & ~B[15] & C[15]) | (A[15] & B[15] & ~C[15]) ) Flags[2] = 1'h1; //set overflow
         else Flags [2] = 1'h0;
         Flags[4] = C[15];              
         Flags[1:0] = 2'h0;
      end

   ADDU:
      begin 
         {Flags[0], C} = A + B;
         if (C == 16'h0000) Flags[3] = 1'h1;                       //set zero bit if answer is 0
         else Flags[3] = 1'h0;
         Flags[4] = 1'h0;              
         Flags[2:1] = 2'h0;
      end

   ADDUI:
      begin 
         {Flags[0], C} = A + B;
         if (C == 16'h0000) Flags[3] = 1'h1;                                         //set zero bit if answer is 0
         else Flags[3] = 1'h0;
         Flags[4] = 1'h0;              
         Flags[2:1] = 2'h0;
      end

   ADDC:
      begin
         {Flags[0], C} = A + B + Cin;
         if (C == 16'h0000) Flags[3] = 1'h1;                                         //set zero bit if answer is 0
         else Flags[3] = 1'h0;
         if( (~A[15] & ~B[15] & C[15]) | (A[15] & B[15] & ~C[15]) ) Flags[2] = 1'h1; //set overflow
         else Flags [2] = 1'h0;
         Flags[4] = C[15];              
         Flags[1:0] = 2'h0;                 
      end
   
   ADDCU:
      begin
         {Flags[0], C} = A + B + Cin;
         if (C == 16'h0000) Flags[3] = 1'h1;                       //set zero bit if answer is 0
         else Flags[3] = 1'h0;
         Flags[4] = 1'h0;              
         Flags[2:1] = 2'h0;
      end

   ADDCUI:            // add with carry, unsigned, immediate
        begin
        {Flags[0], C} = A + B + Cin;        // carry
        Flags[3] = (C == 16'b0);                // zero
        Flags[4] = C[15];                        // negative
        Flags[2:1] = 2'b00;                    // unused flag and low
        end

   ADDCI:            // add with carry, immediate
        begin
        {Flags[0], C} = A + B + Cin;        // carry
        Flags[3] = (C == 16'b0);                // zero
        Flags[4] = C[15];                        // negative

        // check for signed overflow
        if ((A[15] == B[15]) && (A[15] != C[15]))
            Flags[2] = 1'b1;                    // overflow
        else
            Flags[2] = 1'b0;                    // no overflow

        Flags[1] = 1'b0;                        // unused low
        end

   SUB:
        begin
        C = A - B;
        Flags[3] = (C == 16'b0);                // zero
        Flags[4] = C[15];                        // negative

        // check for overflow
        if ((A[15] != B[15]) && (C[15] != A[15]))
            Flags[2] = 1'b1;                    // overflow
        else
            Flags[2] = 1'b0;                    // no overflow

        Flags[1] = (A < B);                    // low
        Flags[0] = (A >= B);                    // carry (borrowing -> 0)
        end

   SUBI:                // sub with immediate
        begin
        C = A - B;
        Flags[3] = (C == 16'b0);
        Flags[4] = C[15];                        // zero

        // check for overflow
        if ((A[15] != B[15]) && (C[15] != A[15]))
            Flags[2] = 1'b1;                    // overflow
        else
            Flags[2] = 1'b0;                    // no overflow

        Flags[1] = (A < B);                    // low
        Flags[0] = (A >= B);                    // carry (borrowing)
        end
   
   CMP:
        begin
        if($signed(A) < $signed(B)) begin 
            Flags[1] = 1'b1;                // low
            Flags[0] = 1'b0;               // carry
         end
        else begin
            Flags[1] = 1'b0;               
            Flags[0] = 1'b1;
         end
        Flags[3] = (A == B);                    // zero if equal
        Flags[4] = ($signed(A) < $signed(B));   // negative if A is less than B
        Flags[2] = 1'b0;                        // no overflow
        C = 16'b0;
        end

    CMPI:                // compare with immediate
        begin
        if($signed(A) < $signed(B)) begin 
            Flags[1] = 1'b1;                // low
            Flags[0] = 1'b0;               // carry
         end
        else begin
            Flags[1] = 1'b0;               
            Flags[0] = 1'b1;
         end                // no low and carry
        Flags[3] = (A == B);                    // zero if equal
        Flags[4] = ($signed(A) < $signed(B));   // negative if A is less than B
        Flags[2] = 1'b0;                        // no overflow
        C = 16'b0;
        end
   
   CMPU: 
        begin
        // unsigned â†’ Low / Carry
        if (A < B) 
            begin          // unsigned
            Flags[1] = 1'b1;      // Low = 1 (A < B)
            Flags[0] = 1'b0;      // C   = 0 (borrow)
            end 
        else 
            begin
            Flags[1] = 1'b0;      // Low = 0
            Flags[0] = 1'b1;      // C   = 1 (A >= B, not-borrow)
            end

        Flags[3] = (A == B);      // Z = 1 if equal
        Flags[2] = 1'b0;          // V = 0 
        Flags[4] = 1'b0;          // N = 0 

        C = 16'b0;
        end
   
   AND:
      begin
      C = A & B;
      Flags[4] = C[15];
      Flags[3] = (C == 16'h0000);
      Flags[2] = 1'b0;
      Flags[1] = 1'b0;
      Flags[0] = 1'b0;      
      end
   
   OR:
      begin
      C = A | B;
      Flags[4] = C[15];
      Flags[3] = (C == 16'h0000);
      Flags[2] = 1'b0;
      Flags[1] = 1'b0;
      Flags[0] = 1'b0;      
      end
   
   XOR:
      begin
      C = A ^ B;
      Flags[4] = C[15];
      Flags[3] = (C == 16'h0000);
      Flags[2] = 1'b0;
      Flags[1] = 1'b0;
      Flags[0] = 1'b0;      
      end      
   
   NOT:
      begin
      C = ~ A;
      Flags[4] = C[15];
      Flags[3] = (C == 16'h0000);
      Flags[2] = 1'b0;
      Flags[1] = 1'b0;
      Flags[0] = 1'b0;      
      end      

   LSH:  //Logical shift left
      begin
      C = A << B[4:0];
      Flags[4] = 1'b0;
      Flags[3] = (C == 16'h0000);
      Flags[2] = 1'b0;
      Flags[1] = 1'b0;
      Flags[0] = 1'b0;   
      end
   
   LSHI: //Logical shift left with immediate
      begin
      C = A << B[4:0];
      Flags[4] = 1'b0;
      Flags[3] = (C == 16'h0000);
      Flags[2] = 1'b0;
      Flags[1] = 1'b0;
      Flags[0] = 1'b0;   
      end


   RSH: //Logical shift right
      begin
        C = A >> B[4:0];
        Flags[4] = 1'b0;
        Flags[3] = (C == 16'h0000);
        Flags[2] = 1'b0;
        Flags[1] = 1'b0;
        Flags[0] = 1'b0;
      end

   RSHI: //Logical shift right with immediate
    begin
      C = A >> B[4:0];
      Flags[4] = 1'b0;
      Flags[3] = (C == 16'h0000);
      Flags[2] = 1'b0;
      Flags[1] = 1'b0;
      Flags[0] = 1'b0;   
      end

   ALSH: //Arithmetic shift left
      begin
        C = A << B[4:0];
        Flags[4] = C[15];
        Flags[3] = (C == 16'h0000);
        Flags[2] = 1'b0;
        Flags[1] = 1'b0;
        Flags[0] = 1'b0;
      end

    ARSH: //Arithmetic shift right
      begin
        C = $signed(A) >>> B[4:0]; // Maintain sign and right shift
        Flags[4] = C[15];
        Flags[3] = (C == 16'h0000);
        Flags[2] = 1'b0;
        Flags[1] = 1'b0;
        Flags[0] = 1'b0;
      end

    NOP: // No operation, pass input A to output
       begin
        C = A;
        Flags[4] = 1'b0;
        Flags[3] = 1'b0;
        Flags[2] = 1'b0;
        Flags[1] = 1'b0;
        Flags[0] = 1'b0;
      end
   
   endcase
end   



    wire [3:0] bcd4 = C[15:12];
    wire [3:0] bcd3 = C[11:8];
    wire [3:0] bcd2 = C[7:4];
    wire [3:0] bcd1 = C[3:0];

always @(*) begin
    case (bcd4)
        4'b0000 : begin seven_seg4 = ~7'b1111110; end  // 0
        4'b0001 : begin seven_seg4 = ~7'b0110000; end  // 1
        4'b0010 : begin seven_seg4 = ~7'b1101101; end  // 2
        4'b0011 : begin seven_seg4 = ~7'b1111001; end  // 3
        4'b0100 : begin seven_seg4 = ~7'b0110011; end  // 4
        4'b0101 : begin seven_seg4 = ~7'b1011011; end  // 5
        4'b0110 : begin seven_seg4 = ~7'b1011111; end  // 6
        4'b0111 : begin seven_seg4 = ~7'b1110000; end  // 7
        4'b1000 : begin seven_seg4 = ~7'b1111111; end  // 8
        4'b1001 : begin seven_seg4 = ~7'b1110011; end  // 9

        4'b1010 : begin seven_seg4 = ~7'b1110111; end  // A
        4'b1011 : begin seven_seg4 = ~7'b0011111; end  // b
        4'b1100 : begin seven_seg4 = ~7'b1001110; end  // C
        4'b1101 : begin seven_seg4 = ~7'b0111101; end  // d
        4'b1110 : begin seven_seg4 = ~7'b1001111; end  // E
        4'b1111 : begin seven_seg4 = ~7'b1000111; end  // F

        default : begin seven_seg4 = ~7'b0000000; end
    endcase
end



always @(*) begin
    case (bcd3)
        4'b0000 : begin seven_seg3 = ~7'b1111110; end  // 0
        4'b0001 : begin seven_seg3 = ~7'b0110000; end  // 1
        4'b0010 : begin seven_seg3 = ~7'b1101101; end  // 2
        4'b0011 : begin seven_seg3 = ~7'b1111001; end  // 3
        4'b0100 : begin seven_seg3 = ~7'b0110011; end  // 4
        4'b0101 : begin seven_seg3 = ~7'b1011011; end  // 5
        4'b0110 : begin seven_seg3 = ~7'b1011111; end  // 6
        4'b0111 : begin seven_seg3 = ~7'b1110000; end  // 7
        4'b1000 : begin seven_seg3 = ~7'b1111111; end  // 8
        4'b1001 : begin seven_seg3 = ~7'b1110011; end  // 9

        4'b1010 : begin seven_seg3 = ~7'b1110111; end  // A
        4'b1011 : begin seven_seg3 = ~7'b0011111; end  // b
        4'b1100 : begin seven_seg3 = ~7'b1001110; end  // C
        4'b1101 : begin seven_seg3 = ~7'b0111101; end  // d
        4'b1110 : begin seven_seg3 = ~7'b1001111; end  // E
        4'b1111 : begin seven_seg3 = ~7'b1000111; end  // F

        default : begin seven_seg3 = ~7'b0000000; end
    endcase
end



always @(*) begin
    case (bcd2)
        4'b0000 : begin seven_seg2 = ~7'b1111110; end  // 0
        4'b0001 : begin seven_seg2 = ~7'b0110000; end  // 1
        4'b0010 : begin seven_seg2 = ~7'b1101101; end  // 2
        4'b0011 : begin seven_seg2 = ~7'b1111001; end  // 3
        4'b0100 : begin seven_seg2 = ~7'b0110011; end  // 4
        4'b0101 : begin seven_seg2 = ~7'b1011011; end  // 5
        4'b0110 : begin seven_seg2 = ~7'b1011111; end  // 6
        4'b0111 : begin seven_seg2 = ~7'b1110000; end  // 7
        4'b1000 : begin seven_seg2 = ~7'b1111111; end  // 8
        4'b1001 : begin seven_seg2 = ~7'b1110011; end  // 9

        4'b1010 : begin seven_seg2 = ~7'b1110111; end  // A
        4'b1011 : begin seven_seg2 = ~7'b0011111; end  // b
        4'b1100 : begin seven_seg2 = ~7'b1001110; end  // C
        4'b1101 : begin seven_seg2 = ~7'b0111101; end  // d
        4'b1110 : begin seven_seg2 = ~7'b1001111; end  // E
        4'b1111 : begin seven_seg2 = ~7'b1000111; end  // F

        default : begin seven_seg2 = ~7'b0000000; end
    endcase
end




always @(*) begin
    case (bcd1)
        4'b0000 : begin seven_seg1 = ~7'b1111110; end  // 0
        4'b0001 : begin seven_seg1 = ~7'b0110000; end  // 1
        4'b0010 : begin seven_seg1 = ~7'b1101101; end  // 2
        4'b0011 : begin seven_seg1 = ~7'b1111001; end  // 3
        4'b0100 : begin seven_seg1 = ~7'b0110011; end  // 4
        4'b0101 : begin seven_seg1 = ~7'b1011011; end  // 5
        4'b0110 : begin seven_seg1 = ~7'b1011111; end  // 6
        4'b0111 : begin seven_seg1 = ~7'b1110000; end  // 7
        4'b1000 : begin seven_seg1 = ~7'b1111111; end  // 8
        4'b1001 : begin seven_seg1 = ~7'b1110011; end  // 9

        4'b1010 : begin seven_seg1 = ~7'b1110111; end  // A
        4'b1011 : begin seven_seg1 = ~7'b0011111; end  // b
        4'b1100 : begin seven_seg1 = ~7'b1001110; end  // C
        4'b1101 : begin seven_seg1 = ~7'b0111101; end  // d
        4'b1110 : begin seven_seg1 = ~7'b1001111; end  // E
        4'b1111 : begin seven_seg1 = ~7'b1000111; end  // F

        default : begin seven_seg1 = ~7'b0000000; end
    endcase
end

endmodule
