module Lab1(
    input [7:0] Opcode,
    input Cin,
    output [15:0] C,
    output [4:0] Flags,
    output [6:0] seven_seg3, // C[15:12]
    output [6:0] seven_seg2, // C[11:8]
    output [6:0] seven_seg1, // C[7:4]
    output [6:0] seven_seg0  // C[3:0]
);

// Hard-coded operands
wire [15:0] A_const = 16'd10;
wire [15:0] B_const = 16'd2;

ALU u_alu (
    .A(A_const),
    .B(B_const),
    .Opcode(Opcode),
    .Cin(Cin),
    .C(C),
    .Flags(Flags),
    .seven_seg3(seven_seg3),
    .seven_seg2(seven_seg2),
    .seven_seg1(seven_seg1),
    .seven_seg0(seven_seg0)
);

endmodule


module ALU(
    A, B, C, Cin, Opcode, Flags,
    seven_seg3, seven_seg2, seven_seg1, seven_seg0
);

input [15:0] A, B;         // 16 bits
input [7:0] Opcode;        // 8 bits
input Cin;
output reg [15:0] C;       // 16 bits
output reg [4:0] Flags;    // 5 flags
output reg [6:0] seven_seg3;
output reg [6:0] seven_seg2;
output reg [6:0] seven_seg1;
output reg [6:0] seven_seg0;

// Opcodes
parameter ADD    = 8'h00;
parameter ADDI   = 8'h01;
parameter ADDU   = 8'h02;
parameter ADDUI  = 8'h03;
parameter ADDC   = 8'h04;
parameter ADDCU  = 8'h05;
parameter ADDCUI = 8'h06;
parameter ADDCI  = 8'h07;
parameter SUB    = 8'h08;
parameter SUBI   = 8'h09;
parameter CMP    = 8'h0A;
parameter CMPI   = 8'h0B;
parameter CMPU   = 8'h0C; // CMPU/I
parameter AND    = 8'h0D;
parameter OR     = 8'h0E;
parameter XOR    = 8'h0F;
parameter NOT    = 8'h10;
parameter LSH    = 8'h11;
parameter LSHI   = 8'h12;
parameter RSH    = 8'h13;
parameter RSHI   = 8'h14;
parameter ALSH   = 8'h15;
parameter ARSH   = 8'h16;
parameter NOP    = 8'h17;

/* FLAGS (bit):
   [4]: Negative
   [3]: Z (zero)
   [2]: Flag
   [1]: Low
   [0]: Carry
*/

always @(A,B,Opcode) begin
    C = 16'h0000;
    Flags = 5'b00000;
    case (Opcode)

        ADD: begin
            {Flags[0], C} = A + B;
            if (C == 16'h0000) Flags[3] = 1'h1;
            else Flags[3] = 1'h0;
            if ((~A[15] & ~B[15] & C[15]) | (A[15] & B[15] & ~C[15]))
                Flags[2] = 1'h1;
            else
                Flags[2] = 1'h0;
            Flags[4] = C[15];
            Flags[1] = 1'h0;
        end

        ADDI: begin
            {Flags[0], C} = A + B;
            if (C == 16'h0000) Flags[3] = 1'h1;
            else Flags[3] = 1'h0;
            if ((~A[15] & ~B[15] & C[15]) | (A[15] & B[15] & ~C[15]))
                Flags[2] = 1'h1;
            else
                Flags[2] = 1'h0;
            Flags[4] = C[15];
            Flags[1:0] = 2'h0;
        end

        ADDU: begin
            {Flags[0], C} = A + B;
            if (C == 16'h0000) Flags[3] = 1'h1;
            else Flags[3] = 1'h0;
            Flags[4] = 1'h0;
            Flags[2:1] = 2'h0;
        end

        ADDUI: begin
            {Flags[0], C} = A + B;
            if (C == 16'h0000) Flags[3] = 1'h1;
            else Flags[3] = 1'h0;
            Flags[4] = 1'h0;
            Flags[2:1] = 2'h0;
        end

        ADDC: begin
            {Flags[0], C} = A + B + Cin;
            if (C == 16'h0000) Flags[3] = 1'h1;
            else Flags[3] = 1'h0;
            if ((~A[15] & ~B[15] & C[15]) | (A[15] & B[15] & ~C[15]))
                Flags[2] = 1'h1;
            else
                Flags[2] = 1'h0;
            Flags[4] = C[15];
            Flags[1:0] = 2'h0;
        end

        ADDCU: begin
            {Flags[0], C} = A + B + Cin;
            if (C == 16'h0000) Flags[3] = 1'h1;
            else Flags[3] = 1'h0;
            Flags[4] = 1'h0;
            Flags[2:1] = 2'h0;
        end

        ADDCUI: begin
            {Flags[0], C} = A + B + Cin;
            Flags[3] = (C == 16'b0);
            Flags[4] = C[15];
            Flags[2:1] = 2'b00;
        end

        ADDCI: begin
            {Flags[0], C} = A + B + Cin;
            Flags[3] = (C == 16'b0);
            Flags[4] = C[15];
            if ((A[15] == B[15]) && (A[15] != C[15]))
                Flags[2] = 1'b1;
            else
                Flags[2] = 1'b0;
            Flags[1] = 1'b0;
        end

        SUB: begin
            C = A - B;
            Flags[3] = (C == 16'b0);
            Flags[4] = C[15];
            if ((A[15] != B[15]) && (C[15] != A[15]))
                Flags[2] = 1'b1;
            else
                Flags[2] = 1'b0;
            Flags[1] = (A < B);
            Flags[0] = (A >= B);
        end

        SUBI: begin
            C = A - B;
            Flags[3] = (C == 16'b0);
            Flags[4] = C[15];
            if ((A[15] != B[15]) && (C[15] != A[15]))
                Flags[2] = 1'b1;
            else
                Flags[2] = 1'b0;
            Flags[1] = (A < B);
            Flags[0] = (A >= B);
        end

        CMP: begin
            if ($signed(A) < $signed(B)) begin
                Flags[1] = 1'b1;
                Flags[0] = 1'b0;
            end else begin
                Flags[1] = 1'b0;
                Flags[0] = 1'b1;
            end
            Flags[3] = (A == B);
            Flags[4] = ($signed(A) < $signed(B));
            Flags[2] = 1'b0;
            C = 16'b0;
        end

        CMPI: begin
            if ($signed(A) < $signed(B)) begin
                Flags[1] = 1'b1;
                Flags[0] = 1'b0;
            end else begin
                Flags[1] = 1'b0;
                Flags[0] = 1'b1;
            end
            Flags[3] = (A == B);
            Flags[4] = ($signed(A) < $signed(B));
            Flags[2] = 1'b0;
            C = 16'b0;
        end

        CMPU: begin
            if (A < B) begin
                Flags[1] = 1'b1;
                Flags[0] = 1'b0;
            end else begin
                Flags[1] = 1'b0;
                Flags[0] = 1'b1;
            end
            Flags[3] = (A == B);
            Flags[2] = 1'b0;
            Flags[4] = 1'b0;
            C = 16'b0;
        end

        AND: begin
            C = A & B;
            Flags[4] = C[15];
            Flags[3] = (C == 16'h0000);
            Flags[2] = 1'b0;
            Flags[1] = 1'b0;
            Flags[0] = 1'b0;
        end

        OR: begin
            C = A | B;
            Flags[4] = C[15];
            Flags[3] = (C == 16'h0000);
            Flags[2] = 1'b0;
            Flags[1] = 1'b0;
            Flags[0] = 1'b0;
        end

        XOR: begin
            C = A ^ B;
            Flags[4] = C[15];
            Flags[3] = (C == 16'h0000);
            Flags[2] = 1'b0;
            Flags[1] = 1'b0;
            Flags[0] = 1'b0;
        end

        NOT: begin
            C = ~A;
            Flags[4] = C[15];
            Flags[3] = (C == 16'h0000);
            Flags[2] = 1'b0;
            Flags[1] = 1'b0;
            Flags[0] = 1'b0;
        end

        LSH: begin
            C = A << B[4:0];
            Flags[4] = 1'b0;
            Flags[3] = (C == 16'h0000);
            Flags[2] = 1'b0;
            Flags[1] = 1'b0;
            Flags[0] = 1'b0;
        end

        LSHI: begin
            C = A << B[4:0];
            Flags[4] = 1'b0;
            Flags[3] = (C == 16'h0000);
            Flags[2] = 1'b0;
            Flags[1] = 1'b0;
            Flags[0] = 1'b0;
        end

        RSH: begin
            C = A >> B[4:0];
            Flags[4] = 1'b0;
            Flags[3] = (C == 16'h0000);
            Flags[2] = 1'b0;
            Flags[1] = 1'b0;
            Flags[0] = 1'b0;
        end

        RSHI: begin
            C = A >> B[4:0];
            Flags[4] = 1'b0;
            Flags[3] = (C == 16'h0000);
            Flags[2] = 1'b0;
            Flags[1] = 1'b0;
            Flags[0] = 1'b0;
        end

        ALSH: begin
            C = A << B[4:0];
            Flags[4] = C[15];
            Flags[3] = (C == 16'h0000);
            Flags[2] = 1'b0;
            Flags[1] = 1'b0;
            Flags[0] = 1'b0;
        end

        ARSH: begin
            C = $signed(A) >>> B[4:0];
            Flags[4] = C[15];
            Flags[3] = (C == 16'h0000);
            Flags[2] = 1'b0;
            Flags[1] = 1'b0;
            Flags[0] = 1'b0;
        end

        NOP: begin
            C = A;
            Flags = 5'b00000;
        end

    endcase
end


function [6:0] hex7seg_ah;
    input [3:0] n;
    begin
        case (n)
            4'b0000: hex7seg_ah = 7'b0111111;
            4'b0001: hex7seg_ah = 7'b0000110;
            4'b0010: hex7seg_ah = 7'b1011011;
            4'b0011: hex7seg_ah = 7'b1001111;
            4'b0100: hex7seg_ah = 7'b1100110;
            4'b0101: hex7seg_ah = 7'b1101101;
            4'b0110: hex7seg_ah = 7'b1111101;
            4'b0111: hex7seg_ah = 7'b0000111;
            4'b1000: hex7seg_ah = 7'b1111111;
            4'b1001: hex7seg_ah = 7'b1100111;
            4'b1010: hex7seg_ah = 7'b1110111; // A
            4'b1011: hex7seg_ah = 7'b1111100; // b
            4'b1100: hex7seg_ah = 7'b0111001; // C
            4'b1101: hex7seg_ah = 7'b1011110; // d
            4'b1110: hex7seg_ah = 7'b1111001; // E
            4'b1111: hex7seg_ah = 7'b1110001; // F
            default: hex7seg_ah = 7'b0000000;
        endcase
    end
endfunction

wire [3:0] bcd4 = C[15:12];
wire [3:0] bcd3 = C[11:8];
wire [3:0] bcd2 = C[7:4];
wire [3:0] bcd1 = C[3:0];

always @(*) begin
    seven_seg3 = ~hex7seg_ah(bcd4);
    seven_seg2 = ~hex7seg_ah(bcd3);
    seven_seg1 = ~hex7seg_ah(bcd2);
    seven_seg0 = ~hex7seg_ah(bcd1);
end

endmodule
