`timescale 1ns/1ps

// Testbench for Lab1 ALU â€” one or more tests per opcode.
// NOTE: For opcodes defined with 'x' bits in the RTL (e.g., 0101xxxx), this TB uses a concrete representative value.

module tb_ALU;

  // DUT ports
  reg  [15:0] A, B;
  reg  [7:0]  Opcode;
  wire [15:0] C;
  wire [4:0]  Flags;

  // Instantiate DUT
  ALU dut (
    .A(A),
    .B(B),
    .Opcode(Opcode),
    .C(C),
    .Flags(Flags)
  );

  // Dump waves
  initial begin
    $dumpfile("tb_ALU.vcd");
    $dumpvars(0, tb_ALU);
  end

  // Pretty print
  task automatic show(input [1023:0] label);
    begin
      #1; // allow combinational settle
      $display("[%0t] %-10s | OP=%b A=%h B=%h  =>  C=%h  Flags(NZVLC)=%b",
               $time, label, Opcode, A, B, C, Flags);
    end
  endtask

  // Single test runner
  task automatic run
  (
    input [1023:0] label,
    input [7:0]    op,
    input [15:0]   a,
    input [15:0]   b
  );
    begin
      Opcode = op; A = a; B = b; #1; show(label);
    end
  endtask

  // Representative concrete values for pattern opcodes (xxxx / 0x)
  localparam [7:0] ADDI_OP   = 8'b0101_0000; // 0101xxxx -> 0101_0000
  localparam [7:0] ADDUI_OP  = 8'b0110_0000; // 0110xxxx -> 0110_0000
  localparam [7:0] ADDCUI_OP = 8'b1101_0000; // 1101xxxx -> 1101_0000
  localparam [7:0] ADDCI_OP  = 8'b0111_0000; // 0111xxxx -> 0111_0000
  localparam [7:0] SUBI_OP   = 8'b1001_0000; // 1001xxxx -> 1001_0000
  localparam [7:0] CMPI_OP   = 8'b1011_0000; // 1011xxxx -> 1011_0000
  localparam [7:0] CMPUI_OP  = 8'b1110_0000; // 1110xxxx -> 1110_0000
  localparam [7:0] LSHI_OP   = 8'b1000_0000; // 1000000x -> 1000_0000
  localparam [7:0] RSHI_OP   = 8'b1000_1000; // 1000100x -> 1000_1000

  // Exact opcodes (no wildcards)
  localparam [7:0] ADD_OP    = 8'b0000_0101;
  localparam [7:0] ADDU_OP   = 8'b0000_0110;
  localparam [7:0] ADDC_OP   = 8'b0000_0111;
  localparam [7:0] ADDCU_OP  = 8'b0000_1000; // not in ISA
  localparam [7:0] SUB_OP    = 8'b0000_1001;
  localparam [7:0] CMP_OP    = 8'b0000_1011;
  localparam [7:0] CMPU_OP   = 8'b0000_1111; // not in ISA
  localparam [7:0] AND_OP    = 8'b0000_0001;
  localparam [7:0] OR_OP     = 8'b0000_0010;
  localparam [7:0] XOR_OP    = 8'b0000_0011;
  localparam [7:0] NOT_OP    = 8'b0000_0100; // not in ISA
  localparam [7:0] LSH_OP    = 8'b1000_0100;
  localparam [7:0] RSH_OP    = 8'b1000_1100; // not in ISA
  localparam [7:0] ALSH_OP   = 8'b1000_0010; // not in ISA
  localparam [7:0] ARSH_OP   = 8'b1000_0011; // not in ISA
  localparam [7:0] NOP_OP    = 8'b0000_0000;

  // A few reusable operand sets
  localparam [15:0] A0 = 16'h0001, B0 = 16'h0001;
  localparam [15:0] A1 = 16'h7FFF, B1 = 16'h0001;
  localparam [15:0] A2 = 16'h8000, B2 = 16'h0001;
  localparam [15:0] A3 = 16'h00F0, B3 = 16'h0F00;
  localparam [15:0] A4 = 16'hAAAA, B4 = 16'h5555;
  localparam [15:0] A5 = 16'h8001, B5 = 16'h8001;
  localparam [15:0] A6 = 16'h1234, B6 = 16'h0004; // shift by 4
  localparam [15:0] A7 = 16'hF234, B7 = 16'h0004; // negative for ARSH
  localparam [15:0] A8 = 16'h0000, B8 = 16'h0000;

  initial begin
    // init
    A = 0; B = 0; Opcode = NOP_OP; #2;

    // ---- Arithmetic ----
    run("ADD   (1+1)",        ADD_OP,    A0, B0);
    run("ADD   (7FFF+1)",     ADD_OP,    A1, B1);
    run("ADD   (8000+1)",     ADD_OP,    A2, B2);

    run("ADDI  (reg+imm)",    ADDI_OP,   A0, 16'h0003);
    run("ADDI  (overflow?)",  ADDI_OP,   A1, 16'h0002);

    run("ADDU  (unsigned)",   ADDU_OP,   16'hFFFF, 16'h0001);
    run("ADDUI (unsigned)",   ADDUI_OP,  16'h00FF, 16'h0001);

    run("ADDC  (with Cin)",   ADDC_OP,   A1, B1);
    run("ADDCU (with Cin,U)", ADDCU_OP,  16'hFFFF, 16'h0000);

    run("ADDCUI(rep)",        ADDCUI_OP, 16'h00FF, 16'h0001);
    run("ADDCI (rep)",        ADDCI_OP,  A0, 16'h0000);

    run("SUB   (A-B)",        SUB_OP,    16'h0003, 16'h0002);
    run("SUB   (borrow)",     SUB_OP,    16'h0000, 16'h0001);
    run("SUBI  (rep)",        SUBI_OP,   16'h0005, 16'h0002);

    // ---- Compare ----
    run("CMP   (A<B?)",       CMP_OP,    16'hFFFE, 16'h0001);
    run("CMP   (A==B)",       CMP_OP,    16'h0ACE, 16'h0ACE);
    run("CMPI  (rep)",        CMPI_OP,   16'h8000, 16'h7FFF);

    run("CMPU  (unsigned)",   CMPU_OP,   16'h0001, 16'hFFFF);
    run("CMPUI (rep)",        CMPUI_OP,  16'hFFFF, 16'h0001);

    // ---- Logic ----
    run("AND",                AND_OP,    A4, B4);
    run("OR",                 OR_OP,     A3, B3);
    run("XOR",                XOR_OP,    A4, B4);
    run("NOT",                NOT_OP,    A3, 16'h0000);

    // ---- Shifts ----
    run("LSH (<<)",           LSH_OP,    A6, B6);
    run("LSHI(rep)",          LSHI_OP,   A6, 16'h0003);

    run("RSH (>>)",           RSH_OP,    A6, B6);
    run("RSHI(rep)",          RSHI_OP,   A6, 16'h0003);

    run("ALSH (arith left?)", ALSH_OP,   A6, B6);
    run("ARSH (>>> signed)",  ARSH_OP,   A7, B7);

    // ---- NOP ----
    run("NOP",                NOP_OP,    16'hDEAD, 16'hBEEF);

    // ---- Edge/Zero ----
    run("ADD zero",           ADD_OP,    A8, B8);
    run("AND zero",           AND_OP,    A8, B8);
    run("XOR self=0",         XOR_OP,    16'hCAFE, 16'hCAFE);

    $display("=== TB done ===");
    #5 $finish;
  end

endmodule
